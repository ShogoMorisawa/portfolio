/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useImperativeHandle, useLayoutEffect } from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";

type ActionName = "Armature_Cocoアクション";

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    LeftBlackEye: THREE.Mesh;
    LeftWhiteEye: THREE.Mesh;
    LeftWhitePoint: THREE.Mesh;
    Body: THREE.SkinnedMesh;
    tongue: THREE.SkinnedMesh;
    root_003: THREE.Bone;
  };
  materials: {
    BlackEye: THREE.MeshStandardMaterial;
    Body: THREE.MeshStandardMaterial;
    ["Body.001"]: THREE.MeshStandardMaterial;
    tongue: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

// Playerから受け取る props を定義
interface CocoProps {
  isMoving: boolean;
  moveDirection: number; // 1: 前進, -1: 後退
}

// forwardRef でラップして、親(Player)から ref を受け取れるようにする
export const Model = React.forwardRef<
  THREE.Group,
  React.ComponentPropsWithoutRef<"group"> & CocoProps
>(({ isMoving, moveDirection, ...props }, ref) => {
  const group = React.useRef<THREE.Group>(null);
  // パスを修正 (/models/...)
  const { scene, animations } = useGLTF("/models/coco-transformed.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult;
  const { actions } = useAnimations(animations, group);

  // 親からの ref と、内部の group ref を結合するおまじない
  useImperativeHandle(ref, () => group.current!);

  // マテリアル変更はヤメ！骨への接着だけやる！
  useLayoutEffect(() => {
    // 1. 頭の骨を探す
    let headBone: THREE.Bone | null = null;
    nodes.root_003.traverse((child) => {
      if ((child as THREE.Bone).isBone && child.name.includes("Head")) {
        headBone = child as THREE.Bone;
      }
    });

    // 2. 目玉たちを頭の骨にくっつける（素材の色変えロジックは全部消しました！）
    clone.traverse((obj) => {
      if ((obj as THREE.Mesh).isMesh) {
        const mesh = obj as THREE.Mesh;
        if (mesh.name.includes("Eye") || mesh.name.includes("Point")) {
          if (headBone) {
            headBone.attach(mesh);
          }
        }
      }
    });
  }, [clone, nodes]);

  // アニメーション制御
  useEffect(() => {
    // GLBに含まれるアクション名を取得（ログを見ると 'Armature_Cocoアクション' のようです）
    const actionName = Object.keys(actions)[0];
    const action = actions[actionName];

    if (action) {
      if (isMoving) {
        action.setEffectiveTimeScale(moveDirection);
        action.play();
      } else {
        action.stop();
      }
    }
  }, [isMoving, moveDirection, actions]);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature_Coco">
          <primitive object={nodes.root_003} />
        </group>
        <skinnedMesh
          name="Body"
          geometry={nodes.Body.geometry}
          material={materials["Body.001"]}
          skeleton={nodes.Body.skeleton}
        />
        <skinnedMesh
          name="tongue"
          geometry={nodes.tongue.geometry}
          material={materials.tongue}
          skeleton={nodes.tongue.skeleton}
        />
      </group>
    </group>
  );
});

Model.displayName = "Coco";

useGLTF.preload("/models/coco-transformed.glb");
